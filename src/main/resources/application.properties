logging.pattern.console=%d{HH:mm:ss.SSS} %-12.12thread %-20.20logger{0} %message%n
logging.level.victor=DEBUG
#logging.level.org.hibernate.SQL=DEBUG
#logging.level.root=DEBUG
logging.level.p6spy=DEBUG
logging.level.com.p6spy=DEBUG


spring.jpa.properties.hibernate.cache.use_second_level_cache=true
spring.jpa.properties.hibernate.cache.use_query_cache=true
spring.jpa.properties.hibernate.cache.region.factory_class=org.hibernate.cache.ehcache.EhCacheRegionFactory

#logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE

#spring.datasource.url = jdbc:p6spy:h2:tcp://localhost:9092/~/test
#spring.datasource.driver-class-name=com.p6spy.engine.spy.P6SpyDriver

spring.datasource.url = jdbc:p6spy:h2:tcp://localhost:9092/~/test
spring.datasource.driver-class-name= com.p6spy.engine.spy.P6SpyDriver
spring.datasource.username=sa
spring.datasource.password=sa


# send up to 500 similar inserts via a single network round trip to db.
# best to keep in sync with the **transaction size** (how many new rows i insert at once)
spring.jpa.properties.hibernate.jdbc.batch_size = 500


#reduces connection starvation issues (conn is acquired only at first DB access, not at @Transactional start):
#see https://vladmihalcea.com/why-you-should-always-use-hibernate-connection-provider_disables_autocommit-for-resource-local-jpa-transactions/
spring.jpa.properties.hibernate.connection.provider_disables_autocommit=true


# spring knows many of its users are stupid. so it want to make their lives easier.
# serializing an @Entity as JSON!! SO WRONG from an architectural point of view:
# give to your clients DTOs not the most sacred clases in your code: Entity

# @GetMapping MyEntity find(id) {} will fail if MyEntity has children that have to be lazy loaded.

#    tells spring to release the connection right at @Transaction end; otherwise, it's kept until the http response is sent back
spring.jpa.open-in-view=false
# if you set this prop above: lazy loading will only work within a @Transactional(readOnly=true) method.


# the default is true = the db conn is released back to pool only after the http response is sent and HTTP connection closed.
# for lazy loading to work if your send @Entity a JSON = mistake

# engineering options: first place to go, instead of 20
spring.datasource.hikari.maximum-pool-size=40


spring.jpa.hibernate.naming.implicit-strategy=org.hibernate.boot.model.naming.ImplicitNamingStrategyComponentPathImpl

spring.jpa.hibernate.ddl-auto=create

# ignore errors running schema.sql
#spring.datasource.continue-on-error=true
spring.datasource.separator=//

spring.h2.console.enabled=true
#To see the DB contents with Eclipse or IntelliJ Community:
# Open http://localhost:8080/h2-console/
# Copy the JDBC url from above in there, user=sa, pass=sa   and connect :)

management.endpoints.web.exposure.include=*


#Transaction logging:
#logging.level.org.springframework.orm.jpa.JpaTransactionManager=TRACE
#logging.level.org.springframework.transaction.interceptor.TransactionInterceptor=TRACE

